import fae::collections::list::List

import faylib::Vec2
import sprite::Sprite, Textures

const SlabSize = 10
const MaxGeneration = 4294967295 // u32 max

// TODO: Make fields internal once language has traits
generic T
struct EntityList {
	entities: List<T>
	generations: List<u32>
	free_ranges: List<Range>
	generation: u32
}

method static EntityList
fn new(): EntityList<T> {
	return EntityList<T> {
		entities: List<T>.new()
		generations: List<u32>.new()
		free_ranges: List<Range>.new()
		generation: 0
	}
}

method mut EntityList
fn free() {
	self.entities.free()
	self.generations.free()
	self.free_ranges.free()
}

method mut EntityList
fn push(entity: T): EntityHandle<T> {
	if self.free_ranges.is_empty() {
		let index = self.entities.length()

		self.entities.push(entity)
		self.generations.push(self.generation)

		return EntityHandle<T> {
			index: index.(u32)
			generation: self.generation
		}
	}

	let range = self.free_ranges.items[0].&mut
	let index = range.start
	range.start += 1
	if range.is_empty() => self.free_ranges.remove(0)

	self.entities.items[index] = entity
	assert(self.generations.items[index] > self.generation)
	self.generations.items[index] = self.generation

	return EntityHandle<T> {
		index: index.(u32)
		generation: self.generation
	}
}

method mut EntityList
fn remove(handle: EntityHandle<T>) {
	let entity_index = handle.index.(isize)
	if self.generations.items[entity_index] >= self.generation => return
	self.generations.items[entity_index] = MaxGeneration

	// Find free range with this index on the boundary
	//     If found, expand
	//     Merge with surrounding if necessary
	//
	// Otherwise insert new free range at approprate location

	let ranges = self.free_ranges.items

	mut left_edge: isize = 0
	mut right_edge = ranges.length
	mut middle: isize = 0

	mut has_left = false
	mut has_right = false

	mut after_or_on_left = false
	mut before_or_on_right = false

	while left_edge <= right_edge {
		middle = (left_edge + right_edge) / 2

		has_left = middle - 1 >= 0
		after_or_on_left = has_left.! or ranges[middle - 1].end <= entity_index

		has_right = middle < ranges.length
		before_or_on_right = has_right.! or entity_index <= ranges[middle].start - 1

		if after_or_on_left and before_or_on_right => break

		let range = ranges[middle]
		if range.end <= entity_index => left_edge = middle + 1
		else if range.start > entity_index => right_edge = middle - 1
		else {
			assert(range.contains(entity_index))
			// Somehow we found an existing range which contains the index
			// This should *never* happen and indicates a logic error
			panicf("Removed entity already a free range")
		}
	}

	let left_index = middle - 1
	let right_index = middle

	if has_left and ranges[left_index].end == entity_index {
		// We are on the right edge of the range to the left of us
		// Include us in the range
		ranges[left_index].end += 1

		// If there is a range to the right and it butts up against
		// our range then combine them
		if has_right and ranges[left_index].end == ranges[right_index].start {
			ranges[left_index].end = ranges[right_index].end
			self.free_ranges.remove(right_index)
		}

		return
	}

	if has_right and entity_index + 1 == ranges[right_index].start {
		// We are on the left edge of the range to the right of us
		// Include us in the range
		ranges[right_index].start -= 1

		// If there is a range to the left and it butts up against
		// our range then combine them
		if has_left and ranges[left_index].end == ranges[right_index].start {
			ranges[left_index].end = ranges[right_index].end
			self.free_ranges.remove(right_index)
		}

		return
	}

	// We must not be on an existing range boundary
	// Insert a new free range at the current range index
	let range = entity_index..entity_index + 1
	self.free_ranges.insert(range, middle)
}

method EntityList
fn assert_free_ranges_actually_free() {
	for range in self.free_ranges.items {
		for entity_index in range {
			assert(self.generations.get(entity_index) > self.generation)
		}
	}
}

method EntityList
fn dump_debugging() {
	println(f"Overall capacity: {self.entities.length()}")

	for range, _, is_last in self.free_ranges.items {
		print(f"{range.start}..{range.end} (capacity: {range.length()})")
		if is_last.! => print(", ")
	}

	println("")
	println("")

	for range in self.free_ranges.items {
		if range.length() == 1 {
			print("o")
			continue
		}

		print("<")
		for _, _, is_last in range.start + 1..range.end {
			if is_last => print(">")
			else => print("-")
		}
	}
}

generic T
struct EntityHandle {
	index: u32
	generation: u32
}

struct Entities {
	player: EntityList<Player>
	missile: EntityList<Missile>
	// enemy: EntityList<Enemy>
	// bomb: EntityList<Bomb>
}

method static Entities
fn new(): Entities {
	return Entities {
		player: EntityList<Player>.new()
		missile: EntityList<Missile>.new()
		// enemy: EntityList<Enemy>.new()
		// bomb: EntityList<Bomb>.new()
	}
}

generic T
struct Context {
	window_size: Vec2
	textures: &Textures
	entities: &mut Entities
	delta: f32
	handle: EntityHandle<T>
}

method mut Entities
fn tick(textures: &Textures, window_size: Vec2, delta: f32) {
	// Newly added entities are not ticked until the following frame

	self.player.generation += 1
	for entity, index of self.player.entities.items {
		let generation = self.player.generations.get(index)
		if generation >= self.player.generation => continue

		mut context = Context<Player> {
			window_size
			textures
			entities: self
			delta
			handle: EntityHandle<Player> {
				index: index.(u32),
				generation
			}
		}

		entity.tick(context.&mut)
	}


	self.missile.generation += 1
	for entity, index of self.missile.entities.items {
		let generation = self.missile.generations.get(index)
		if generation >= self.missile.generation => continue

		mut context = Context<Missile> {
			window_size
			textures
			entities: self
			delta
			handle: EntityHandle<Missile> {
				index: index.(u32),
				generation
			}
		}

		entity.tick(context.&mut)
		// self.missile.assert_free_ranges_actually_free()
	}

	// self.missile.assert_free_ranges_actually_free()
	// fae::io::terminal::clear()
	// self.missile.dump_debugging()
}

method mut Entities
fn free() {
	self.player.free()
	self.missile.free()
	// self.enemy.free()
	// self.bomb.free()
}

struct Player {
	sprite: Sprite
	fire_delay: f32
}

method static Player
fn spawn(textures: &Textures, entities: &mut Entities, window_size: Vec2) {
	entities.player.push(Player {
		sprite: Sprite {
			texture: textures.player.&
			position: Vec2 {
				x: window_size.x / 2
				y: window_size.y - textures.player.height.(f32)
			}
		}
		fire_delay: 0
	})
}

method mut Player
fn tick(context: &mut Context<Player>) {
	import faylib::is_key_down

	const Speed = 1500 // Pixels per second
	const FireDelay = 0.3 // Seconds

	mut distance = Vec2.zero()
	if is_key_down(key::A) => distance.x -= Speed * context.delta
	if is_key_down(key::D) => distance.x += Speed * context.delta
	self.sprite.move(context.window_size, distance)

	self.fire_delay -= context.delta
	if self.fire_delay <= 0 and is_key_down(key::W) {
		let half_height = self.sprite.texture.height.(f32) / 2
		let position = Vec2 {
			x: self.sprite.position.x
			y: self.sprite.position.y - half_height
		}
		Missile.fire(context.textures, context.entities, position)
		self.fire_delay = FireDelay
	}

	self.sprite.draw()
}

struct Missile {
	sprite: Sprite
}

method static Missile
fn fire(textures: &Textures, entities: &mut Entities, position: Vec2) {
	entities.missile.push(Missile {
		sprite: Sprite {
			texture: textures.missile.&
			position
		}
	})
}

method mut Missile
fn tick(context: &mut Context<Missile>) {
	const Speed = 1300 // Pixels per second

	let speed = Speed * context.delta
	let distance = Vec2 { x: 0, y: -speed }
	let reached = self.sprite.move(context.window_size, distance)

	if reached.top => context.entities.missile.remove(context.handle)
	else => self.sprite.draw()
}

// struct Enemy {}

// method mut Enemy
// fn tick(_context: &Context<Enemy>) {}

// struct Bomb {}

// method mut Bomb
// fn tick(_context: &Context<Bomb>) {}
