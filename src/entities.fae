import fae::collections::list::List

import faylib::Vec2
import sprite::Sprite, Textures

generic T
struct EntityList {
	entities: List<T> readable
	presence: List<bool> readable
	holes: List<isize> readable
}

method static EntityList
fn new(): EntityList<T> {
	return EntityList<T> {
		entities: List<T>.new()
		presence: List<bool>.new()
		holes: List<isize>.new()
	}
}

method mut EntityList
fn free() {
	self.entities.free()
	self.presence.free()
	self.holes.free()
}

method mut EntityList
fn push(entity: T) {
	self.entities.push(entity)
	self.presence.push(true)
}

method mut EntityList
fn remove(index: isize) {
	self.presence.items[index] = false
}

method mut EntityList
fn entity(index: isize): &mut T {
	return self.entities.items[index].&mut
}

struct Entities {
	player: EntityList<Player>
	enemy: EntityList<Enemy>
	bomb: EntityList<Bomb>
	missile: EntityList<Missile>
}

method static Entities
fn new(): Entities {
	return Entities {
		player: EntityList<Player>.new()
		enemy: EntityList<Enemy>.new()
		bomb: EntityList<Bomb>.new()
		missile: EntityList<Missile>.new()
	}
}

struct Context {
	window_size: Vec2
	textures: &Textures
	entities: &mut Entities
	delta: f32
	entity_index: isize
}

method mut Entities
fn tick(textures: &Textures, window_size: Vec2, delta: f32) {
	mut context = Context {
		window_size
		textures
		entities: self
		delta
		entity_index: 0
	}

	// Newly added entities are not ticked until the following frame

	for index in 0..self.player.entities.items.length {
		if self.player.presence.items[index].! => continue
		context.entity_index = index
		self.player.entity(index).tick(context.&mut)
	}

	for index in 0..self.enemy.entities.items.length {
		if self.enemy.presence.items[index].! => continue
		context.entity_index = index
		self.enemy.entity(index).tick(context.&mut)
	}

	for index in 0..self.bomb.entities.items.length {
		if self.bomb.presence.items[index].! => continue
		context.entity_index = index
		self.bomb.entity(index).tick(context.&mut)
	}

	for index in 0..self.missile.entities.items.length {
		if self.missile.presence.items[index].! => continue
		context.entity_index = index
		self.missile.entity(index).tick(context.&mut)
	}
}

method mut Entities
fn free() {
	self.player.free()
	self.enemy.free()
	self.bomb.free()
	self.missile.free()
}

struct Player {
	sprite: Sprite
	fire_delay: f32
}

method static Player
fn spawn(textures: &Textures, entities: &mut Entities, window_size: Vec2) {
	entities.player.push(Player {
		sprite: Sprite {
			texture: textures.player.&
			position: Vec2 {
				x: window_size.x / 2
				y: window_size.y - textures.player.height.(f32)
			}
		}
		fire_delay: 0
	})
}

method mut Player
fn tick(context: &Context) {
	import faylib::is_key_down

	const Speed = 1500 // Pixels per second
	const FireDelay = 0.1 // Seconds

	mut distance = Vec2.zero()
	if is_key_down(key::A) => distance.x -= Speed * context.delta
	if is_key_down(key::D) => distance.x += Speed * context.delta
	self.sprite.move(context.window_size, distance)

	self.fire_delay -= context.delta
	if self.fire_delay <= 0 and is_key_down(key::W) {
		let half_height = self.sprite.texture.height.(f32) / 2
		let position = Vec2 {
			x: self.sprite.position.x
			y: self.sprite.position.y - half_height
		}
		Missile.fire(context.textures, context.entities, position)
		self.fire_delay = FireDelay
	}

	self.sprite.draw()
}

struct Enemy {}

method mut Enemy
fn tick(_context: &Context) {}

struct Bomb {}

method mut Bomb
fn tick(_context: &Context) {}

struct Missile {
	sprite: Sprite
}

method static Missile
fn fire(textures: &Textures, entities: &mut Entities, position: Vec2) {
	entities.missile.push(Missile {
		sprite: Sprite {
			texture: textures.missile.&
			position
		}
	})
}

method mut Missile
fn tick(context: &mut Context) {
	const Speed = 1000 // Pixels per second

	let speed = Speed * context.delta
	let distance = Vec2 { x: 0, y: -speed }
	let reached = self.sprite.move(context.window_size, distance)

	if reached.top => context.entities.missile.remove(context.entity_index)
	else => self.sprite.draw()
}
