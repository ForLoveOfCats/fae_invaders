import faylib::Vec2
import sprite::Sprite, Textures
import entity_system::EntitySystem, EntityHandle, Context
import entities::player::Player
import scene::Scene

struct Bomb {
	sprite: Sprite
}

method static Bomb
fn fire(textures: &Textures, entity_system: &mut EntitySystem, position: Vec2) {
	entity_system.bomb.push(Bomb {
		sprite: Sprite {
			texture: textures.bomb.&
			position
		}
	})
}

method mut Bomb
fn tick(context: &mut Context<Bomb>) {
	const Speed = 75 // Pixels per second

	let speed = Speed * context.delta
	let distance = Vec2 { x: 0, y: speed }
	let reached = self.sprite.move(context.viewport_size, distance)

	if reached.bottom and context.scene_context.scene is scene: InGame {
		context.entity_system.bomb.remove(context.handle)

		scene.shield_health -= 1
		if scene.shield_health <= 0 {
			let reason = "The Shield Was Detroyed!"
			context.scene_context.transition(Scene.Lost { reason, ok: false })
		}
	}

	// This is dumb as hell and would *not* fly in a more complex project
	for info, index in context.entity_system.player.generations.items {
		if info.may_be_ticked(context.generation).! => continue

		let player = context.entity_system.player.entities.get_ref(index)
		if self.sprite.overlaps(player.sprite) {
			let generation = context.entity_system.player.generations.items[index].added
			let handle = EntityHandle<Player> { index: index.(u32), generation }
			context.entity_system.player.remove(handle)

			context.entity_system.bomb.remove(context.handle)
		}
	}

	self.sprite.draw()
}
