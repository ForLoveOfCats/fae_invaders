import faylib::Vec2
import sprite::Sprite, Textures
import entity_system::EntitySystem, Context
import entities::missile::Missile

struct Player {
	sprite: Sprite
	velocity: Vec2
	fire_delay: f32
}

method static Player
fn spawn(textures: &Textures, entity_system: &mut EntitySystem, window_size: Vec2) {
	entity_system.player.push(Player {
		sprite: Sprite {
			texture: textures.player.&
			position: Vec2 {
				x: window_size.x / 2
				y: window_size.y - textures.player.height.(f32)
			}
		}
		velocity: Vec2.zero()
		fire_delay: 0
	})
}

method mut Player
fn tick(context: &mut Context<Player>) {
	import faylib::is_key_down, is_key_pressed

	const TopSpeed = 1350 // Pixels per second
	const Acceleration = 6000 // Pixels per second per second
	const Drag = 8000 // Pixels per second per second
	const FireDelay = 0.15 // Seconds

	let drag = Drag * context.delta
	let acceleration = Acceleration * context.delta

	if is_key_down(key::A) => self.velocity.x -= acceleration + drag
	if is_key_down(key::D) => self.velocity.x += acceleration + drag

	if self.velocity.x < 0 => self.velocity.x = min(self.velocity.x + drag, 0)
	if self.velocity.x > 0 => self.velocity.x = max(self.velocity.x - drag, 0)

	if self.velocity.x < -TopSpeed => self.velocity.x = -TopSpeed
	if self.velocity.x > TopSpeed => self.velocity.x = TopSpeed

	let distance = Vec2 { x: self.velocity.x * context.delta, y: 0 }
	self.sprite.move(context.window_size, distance)

	self.fire_delay -= context.delta
	if self.fire_delay <= 0 and is_key_pressed(key::W) {
		let half_height = self.sprite.texture.height.(f32) / 2
		let position = Vec2 {
			x: self.sprite.position.x
			y: self.sprite.position.y - half_height
		}
		Missile.fire(context.textures, context.entity_system, position)
		self.fire_delay = FireDelay
	}

	self.sprite.draw()
}

fn min(a: f32, b: f32): f32 {
	if a < b => return a
	return b
}

fn max(a: f32, b: f32): f32 {
	if a > b => return a
	return b
}
